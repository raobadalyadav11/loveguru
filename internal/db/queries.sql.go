// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const approveAdvisor = `-- name: ApproveAdvisor :exec
UPDATE advisors SET is_verified = TRUE, status = 'OFFLINE' WHERE id = $1
`

func (q *Queries) ApproveAdvisor(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, approveAdvisor, id)
	return err
}

const blockUser = `-- name: BlockUser :exec
UPDATE users SET is_active = FALSE WHERE id = $1
`

func (q *Queries) BlockUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, blockUser, id)
	return err
}

const createAdvisor = `-- name: CreateAdvisor :one
INSERT INTO advisors (user_id, bio, experience_years, languages, specializations, hourly_rate)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, bio, experience_years, languages, specializations, is_verified, hourly_rate, status, created_at, updated_at
`

type CreateAdvisorParams struct {
	UserID          uuid.UUID      `json:"user_id"`
	Bio             sql.NullString `json:"bio"`
	ExperienceYears sql.NullInt32  `json:"experience_years"`
	Languages       []string       `json:"languages"`
	Specializations []string       `json:"specializations"`
	HourlyRate      sql.NullString `json:"hourly_rate"`
}

func (q *Queries) CreateAdvisor(ctx context.Context, arg CreateAdvisorParams) (Advisor, error) {
	row := q.db.QueryRowContext(ctx, createAdvisor,
		arg.UserID,
		arg.Bio,
		arg.ExperienceYears,
		pq.Array(arg.Languages),
		pq.Array(arg.Specializations),
		arg.HourlyRate,
	)
	var i Advisor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Bio,
		&i.ExperienceYears,
		pq.Array(&i.Languages),
		pq.Array(&i.Specializations),
		&i.IsVerified,
		&i.HourlyRate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCallSession = `-- name: CreateCallSession :one
INSERT INTO sessions (user_id, advisor_id, type)
VALUES ($1, $2, 'CALL')
RETURNING id, user_id, advisor_id, type, started_at, ended_at, status
`

type CreateCallSessionParams struct {
	UserID    uuid.UUID     `json:"user_id"`
	AdvisorID uuid.NullUUID `json:"advisor_id"`
}

func (q *Queries) CreateCallSession(ctx context.Context, arg CreateCallSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createCallSession, arg.UserID, arg.AdvisorID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AdvisorID,
		&i.Type,
		&i.StartedAt,
		&i.EndedAt,
		&i.Status,
	)
	return i, err
}

const createRating = `-- name: CreateRating :one
INSERT INTO ratings (session_id, user_id, advisor_id, rating, review_text)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, session_id, user_id, advisor_id, rating, review_text, created_at
`

type CreateRatingParams struct {
	SessionID  uuid.UUID      `json:"session_id"`
	UserID     uuid.UUID      `json:"user_id"`
	AdvisorID  uuid.UUID      `json:"advisor_id"`
	Rating     int32          `json:"rating"`
	ReviewText sql.NullString `json:"review_text"`
}

func (q *Queries) CreateRating(ctx context.Context, arg CreateRatingParams) (Rating, error) {
	row := q.db.QueryRowContext(ctx, createRating,
		arg.SessionID,
		arg.UserID,
		arg.AdvisorID,
		arg.Rating,
		arg.ReviewText,
	)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.UserID,
		&i.AdvisorID,
		&i.Rating,
		&i.ReviewText,
		&i.CreatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (user_id, advisor_id, type)
VALUES ($1, $2, $3)
RETURNING id, user_id, advisor_id, type, started_at, ended_at, status
`

type CreateSessionParams struct {
	UserID    uuid.UUID     `json:"user_id"`
	AdvisorID uuid.NullUUID `json:"advisor_id"`
	Type      string        `json:"type"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession, arg.UserID, arg.AdvisorID, arg.Type)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AdvisorID,
		&i.Type,
		&i.StartedAt,
		&i.EndedAt,
		&i.Status,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, phone, password_hash, display_name, role)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, email, phone, password_hash, display_name, role, gender, dob, created_at, updated_at, is_active
`

type CreateUserParams struct {
	Email        sql.NullString `json:"email"`
	Phone        sql.NullString `json:"phone"`
	PasswordHash string         `json:"password_hash"`
	DisplayName  string         `json:"display_name"`
	Role         string         `json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Email,
		arg.Phone,
		arg.PasswordHash,
		arg.DisplayName,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.Gender,
		&i.Dob,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const endCall = `-- name: EndCall :exec
UPDATE sessions SET status = 'ENDED', ended_at = NOW() WHERE id = $1
`

func (q *Queries) EndCall(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, endCall, id)
	return err
}

const getAdvisorByID = `-- name: GetAdvisorByID :one
SELECT a.id, a.user_id, a.bio, a.experience_years, a.languages, a.specializations, a.is_verified, a.hourly_rate, a.status, a.created_at, a.updated_at, u.id, u.email, u.phone, u.password_hash, u.display_name, u.role, u.gender, u.dob, u.created_at, u.updated_at, u.is_active FROM advisors a JOIN users u ON a.user_id = u.id WHERE a.id = $1
`

type GetAdvisorByIDRow struct {
	ID              uuid.UUID      `json:"id"`
	UserID          uuid.UUID      `json:"user_id"`
	Bio             sql.NullString `json:"bio"`
	ExperienceYears sql.NullInt32  `json:"experience_years"`
	Languages       []string       `json:"languages"`
	Specializations []string       `json:"specializations"`
	IsVerified      sql.NullBool   `json:"is_verified"`
	HourlyRate      sql.NullString `json:"hourly_rate"`
	Status          sql.NullString `json:"status"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	ID_2            uuid.UUID      `json:"id_2"`
	Email           sql.NullString `json:"email"`
	Phone           sql.NullString `json:"phone"`
	PasswordHash    string         `json:"password_hash"`
	DisplayName     string         `json:"display_name"`
	Role            string         `json:"role"`
	Gender          sql.NullString `json:"gender"`
	Dob             sql.NullTime   `json:"dob"`
	CreatedAt_2     sql.NullTime   `json:"created_at_2"`
	UpdatedAt_2     sql.NullTime   `json:"updated_at_2"`
	IsActive        sql.NullBool   `json:"is_active"`
}

func (q *Queries) GetAdvisorByID(ctx context.Context, id uuid.UUID) (GetAdvisorByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getAdvisorByID, id)
	var i GetAdvisorByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Bio,
		&i.ExperienceYears,
		pq.Array(&i.Languages),
		pq.Array(&i.Specializations),
		&i.IsVerified,
		&i.HourlyRate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.Gender,
		&i.Dob,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.IsActive,
	)
	return i, err
}

const getAdvisorByUserID = `-- name: GetAdvisorByUserID :one
SELECT id, user_id, bio, experience_years, languages, specializations, is_verified, hourly_rate, status, created_at, updated_at FROM advisors WHERE user_id = $1
`

func (q *Queries) GetAdvisorByUserID(ctx context.Context, userID uuid.UUID) (Advisor, error) {
	row := q.db.QueryRowContext(ctx, getAdvisorByUserID, userID)
	var i Advisor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Bio,
		&i.ExperienceYears,
		pq.Array(&i.Languages),
		pq.Array(&i.Specializations),
		&i.IsVerified,
		&i.HourlyRate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAdvisorRatings = `-- name: GetAdvisorRatings :many
SELECT id, session_id, user_id, advisor_id, rating, review_text, created_at FROM ratings WHERE advisor_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type GetAdvisorRatingsParams struct {
	AdvisorID uuid.UUID `json:"advisor_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) GetAdvisorRatings(ctx context.Context, arg GetAdvisorRatingsParams) ([]Rating, error) {
	rows, err := q.db.QueryContext(ctx, getAdvisorRatings, arg.AdvisorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rating
	for rows.Next() {
		var i Rating
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.UserID,
			&i.AdvisorID,
			&i.Rating,
			&i.ReviewText,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlags = `-- name: GetFlags :many
SELECT id, reported_by, reported_user_id, reported_advisor_id, reason, session_id, created_at, status FROM admin_flags ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type GetFlagsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetFlags(ctx context.Context, arg GetFlagsParams) ([]AdminFlag, error) {
	rows, err := q.db.QueryContext(ctx, getFlags, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminFlag
	for rows.Next() {
		var i AdminFlag
		if err := rows.Scan(
			&i.ID,
			&i.ReportedBy,
			&i.ReportedUserID,
			&i.ReportedAdvisorID,
			&i.Reason,
			&i.SessionID,
			&i.CreatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessages = `-- name: GetMessages :many
SELECT id, session_id, sender_type, sender_id, content, created_at, is_read FROM chat_messages WHERE session_id = $1 ORDER BY created_at LIMIT $2 OFFSET $3
`

type GetMessagesParams struct {
	SessionID uuid.UUID `json:"session_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) GetMessages(ctx context.Context, arg GetMessagesParams) ([]ChatMessage, error) {
	rows, err := q.db.QueryContext(ctx, getMessages, arg.SessionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.SenderType,
			&i.SenderID,
			&i.Content,
			&i.CreatedAt,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingAdvisors = `-- name: GetPendingAdvisors :many
SELECT a.id, a.user_id, a.bio, a.experience_years, a.languages, a.specializations, a.is_verified, a.hourly_rate, a.status, a.created_at, a.updated_at, u.id, u.email, u.phone, u.password_hash, u.display_name, u.role, u.gender, u.dob, u.created_at, u.updated_at, u.is_active FROM advisors a JOIN users u ON a.user_id = u.id WHERE a.status = 'PENDING' LIMIT $1 OFFSET $2
`

type GetPendingAdvisorsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetPendingAdvisorsRow struct {
	ID              uuid.UUID      `json:"id"`
	UserID          uuid.UUID      `json:"user_id"`
	Bio             sql.NullString `json:"bio"`
	ExperienceYears sql.NullInt32  `json:"experience_years"`
	Languages       []string       `json:"languages"`
	Specializations []string       `json:"specializations"`
	IsVerified      sql.NullBool   `json:"is_verified"`
	HourlyRate      sql.NullString `json:"hourly_rate"`
	Status          sql.NullString `json:"status"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	ID_2            uuid.UUID      `json:"id_2"`
	Email           sql.NullString `json:"email"`
	Phone           sql.NullString `json:"phone"`
	PasswordHash    string         `json:"password_hash"`
	DisplayName     string         `json:"display_name"`
	Role            string         `json:"role"`
	Gender          sql.NullString `json:"gender"`
	Dob             sql.NullTime   `json:"dob"`
	CreatedAt_2     sql.NullTime   `json:"created_at_2"`
	UpdatedAt_2     sql.NullTime   `json:"updated_at_2"`
	IsActive        sql.NullBool   `json:"is_active"`
}

func (q *Queries) GetPendingAdvisors(ctx context.Context, arg GetPendingAdvisorsParams) ([]GetPendingAdvisorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingAdvisors, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingAdvisorsRow
	for rows.Next() {
		var i GetPendingAdvisorsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Bio,
			&i.ExperienceYears,
			pq.Array(&i.Languages),
			pq.Array(&i.Specializations),
			&i.IsVerified,
			&i.HourlyRate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Email,
			&i.Phone,
			&i.PasswordHash,
			&i.DisplayName,
			&i.Role,
			&i.Gender,
			&i.Dob,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, user_id, advisor_id, type, started_at, ended_at, status FROM sessions WHERE id = $1
`

func (q *Queries) GetSessionByID(ctx context.Context, id uuid.UUID) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AdvisorID,
		&i.Type,
		&i.StartedAt,
		&i.EndedAt,
		&i.Status,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, phone, password_hash, display_name, role, gender, dob, created_at, updated_at, is_active FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.Gender,
		&i.Dob,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, phone, password_hash, display_name, role, gender, dob, created_at, updated_at, is_active FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.Gender,
		&i.Dob,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const getUserByPhone = `-- name: GetUserByPhone :one
SELECT id, email, phone, password_hash, display_name, role, gender, dob, created_at, updated_at, is_active FROM users WHERE phone = $1
`

func (q *Queries) GetUserByPhone(ctx context.Context, phone sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByPhone, phone)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.Gender,
		&i.Dob,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const getUserSessions = `-- name: GetUserSessions :many
SELECT id, user_id, advisor_id, type, started_at, ended_at, status FROM sessions WHERE user_id = $1 ORDER BY started_at DESC LIMIT $2 OFFSET $3
`

type GetUserSessionsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) GetUserSessions(ctx context.Context, arg GetUserSessionsParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, getUserSessions, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AdvisorID,
			&i.Type,
			&i.StartedAt,
			&i.EndedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAIInteraction = `-- name: InsertAIInteraction :one
INSERT INTO ai_interactions (user_id, prompt, response)
VALUES ($1, $2, $3)
RETURNING id, user_id, prompt, response, created_at
`

type InsertAIInteractionParams struct {
	UserID   uuid.UUID `json:"user_id"`
	Prompt   string    `json:"prompt"`
	Response string    `json:"response"`
}

func (q *Queries) InsertAIInteraction(ctx context.Context, arg InsertAIInteractionParams) (AiInteraction, error) {
	row := q.db.QueryRowContext(ctx, insertAIInteraction, arg.UserID, arg.Prompt, arg.Response)
	var i AiInteraction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Prompt,
		&i.Response,
		&i.CreatedAt,
	)
	return i, err
}

const insertCallLog = `-- name: InsertCallLog :one
INSERT INTO call_logs (session_id, external_call_id, started_at, ended_at, duration_seconds, status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, session_id, external_call_id, started_at, ended_at, duration_seconds, status
`

type InsertCallLogParams struct {
	SessionID       uuid.UUID      `json:"session_id"`
	ExternalCallID  sql.NullString `json:"external_call_id"`
	StartedAt       sql.NullTime   `json:"started_at"`
	EndedAt         sql.NullTime   `json:"ended_at"`
	DurationSeconds sql.NullInt32  `json:"duration_seconds"`
	Status          sql.NullString `json:"status"`
}

func (q *Queries) InsertCallLog(ctx context.Context, arg InsertCallLogParams) (CallLog, error) {
	row := q.db.QueryRowContext(ctx, insertCallLog,
		arg.SessionID,
		arg.ExternalCallID,
		arg.StartedAt,
		arg.EndedAt,
		arg.DurationSeconds,
		arg.Status,
	)
	var i CallLog
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.ExternalCallID,
		&i.StartedAt,
		&i.EndedAt,
		&i.DurationSeconds,
		&i.Status,
	)
	return i, err
}

const insertMessage = `-- name: InsertMessage :one
INSERT INTO chat_messages (session_id, sender_type, sender_id, content)
VALUES ($1, $2, $3, $4)
RETURNING id, session_id, sender_type, sender_id, content, created_at, is_read
`

type InsertMessageParams struct {
	SessionID  uuid.UUID `json:"session_id"`
	SenderType string    `json:"sender_type"`
	SenderID   uuid.UUID `json:"sender_id"`
	Content    string    `json:"content"`
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) (ChatMessage, error) {
	row := q.db.QueryRowContext(ctx, insertMessage,
		arg.SessionID,
		arg.SenderType,
		arg.SenderID,
		arg.Content,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.SenderType,
		&i.SenderID,
		&i.Content,
		&i.CreatedAt,
		&i.IsRead,
	)
	return i, err
}

const listAdvisors = `-- name: ListAdvisors :many
SELECT a.id, a.user_id, a.bio, a.experience_years, a.languages, a.specializations, a.is_verified, a.hourly_rate, a.status, a.created_at, a.updated_at, u.id, u.email, u.phone, u.password_hash, u.display_name, u.role, u.gender, u.dob, u.created_at, u.updated_at, u.is_active, 0 as average_rating
FROM advisors a
JOIN users u ON a.user_id = u.id
WHERE a.status = 'ONLINE'
LIMIT $2 OFFSET $1
`

type ListAdvisorsParams struct {
	OffsetRows int32 `json:"offset_rows"`
	LimitRows  int32 `json:"limit_rows"`
}

type ListAdvisorsRow struct {
	ID              uuid.UUID      `json:"id"`
	UserID          uuid.UUID      `json:"user_id"`
	Bio             sql.NullString `json:"bio"`
	ExperienceYears sql.NullInt32  `json:"experience_years"`
	Languages       []string       `json:"languages"`
	Specializations []string       `json:"specializations"`
	IsVerified      sql.NullBool   `json:"is_verified"`
	HourlyRate      sql.NullString `json:"hourly_rate"`
	Status          sql.NullString `json:"status"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	ID_2            uuid.UUID      `json:"id_2"`
	Email           sql.NullString `json:"email"`
	Phone           sql.NullString `json:"phone"`
	PasswordHash    string         `json:"password_hash"`
	DisplayName     string         `json:"display_name"`
	Role            string         `json:"role"`
	Gender          sql.NullString `json:"gender"`
	Dob             sql.NullTime   `json:"dob"`
	CreatedAt_2     sql.NullTime   `json:"created_at_2"`
	UpdatedAt_2     sql.NullTime   `json:"updated_at_2"`
	IsActive        sql.NullBool   `json:"is_active"`
	AverageRating   int32          `json:"average_rating"`
}

func (q *Queries) ListAdvisors(ctx context.Context, arg ListAdvisorsParams) ([]ListAdvisorsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAdvisors, arg.OffsetRows, arg.LimitRows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAdvisorsRow
	for rows.Next() {
		var i ListAdvisorsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Bio,
			&i.ExperienceYears,
			pq.Array(&i.Languages),
			pq.Array(&i.Specializations),
			&i.IsVerified,
			&i.HourlyRate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Email,
			&i.Phone,
			&i.PasswordHash,
			&i.DisplayName,
			&i.Role,
			&i.Gender,
			&i.Dob,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.IsActive,
			&i.AverageRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAdvisor = `-- name: UpdateAdvisor :one
UPDATE advisors SET bio = $2, experience_years = $3, languages = $4, specializations = $5, hourly_rate = $6, status = $7, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, bio, experience_years, languages, specializations, is_verified, hourly_rate, status, created_at, updated_at
`

type UpdateAdvisorParams struct {
	ID              uuid.UUID      `json:"id"`
	Bio             sql.NullString `json:"bio"`
	ExperienceYears sql.NullInt32  `json:"experience_years"`
	Languages       []string       `json:"languages"`
	Specializations []string       `json:"specializations"`
	HourlyRate      sql.NullString `json:"hourly_rate"`
	Status          sql.NullString `json:"status"`
}

func (q *Queries) UpdateAdvisor(ctx context.Context, arg UpdateAdvisorParams) (Advisor, error) {
	row := q.db.QueryRowContext(ctx, updateAdvisor,
		arg.ID,
		arg.Bio,
		arg.ExperienceYears,
		pq.Array(arg.Languages),
		pq.Array(arg.Specializations),
		arg.HourlyRate,
		arg.Status,
	)
	var i Advisor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Bio,
		&i.ExperienceYears,
		pq.Array(&i.Languages),
		pq.Array(&i.Specializations),
		&i.IsVerified,
		&i.HourlyRate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSessionStatus = `-- name: UpdateSessionStatus :exec
UPDATE sessions SET status = $2, ended_at = NOW() WHERE id = $1
`

type UpdateSessionStatusParams struct {
	ID     uuid.UUID      `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdateSessionStatus(ctx context.Context, arg UpdateSessionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateSessionStatus, arg.ID, arg.Status)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET display_name = $2, gender = $3, dob = $4, updated_at = NOW()
WHERE id = $1
RETURNING id, email, phone, password_hash, display_name, role, gender, dob, created_at, updated_at, is_active
`

type UpdateUserParams struct {
	ID          uuid.UUID      `json:"id"`
	DisplayName string         `json:"display_name"`
	Gender      sql.NullString `json:"gender"`
	Dob         sql.NullTime   `json:"dob"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.DisplayName,
		arg.Gender,
		arg.Dob,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Phone,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.Gender,
		&i.Dob,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}
